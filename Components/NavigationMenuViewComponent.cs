using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using SportsStore.Models;

namespace SportsStore.Components
{

    //Создадим папку по имени Components, которая по соглашению является местом
    //хранения компонентов представлений, и добавим в нее файл класса под названием
    //NavigationMenuViewComponent. cs

    //В инфраструктуре ASP.NET Core MVC поддерживается концепция компонентов представлений,
    //которые идеально подходят для создания единиц вроде многократно используемого навигационного
    //элемента управления. Компонент представления-это класс С#, который предлагает небольшой объем
    //многократно используемой прикладной логики с возможностью выбора и отображения частичных
    //представлений Razor.

    //Создадим компонент  представления, который визуализирует навигационное меню и интегрирует
    //его в приложение за счет обращения  к этому  компоненту из  разделяемой компоновки.Подход
    //подобного рода дает нам обычный класс С#, который может содержать любую необходимую
    //прикладную логику и который можно подвергать модульному тестированию подобно любому
    //другому классу.Такой способ удобен при создании небольших сегментов приложения с
    //одновременным сохранением общего подхода MVC.


    //Метод Invoke() компонента представления вызывается, когда компонент применяется в
    //представлении Razor, а результат, возвращаемый методом Invoke(), вставляется в НТМL-разметку,
    //отправляемую браузеру.Простой компонент представления, который возвращает строку, вскоре
    //заменим его динамическим НТМL-содержимым.

   // Список категорий должен присутствовать на всех страницах, поэтому мы собираемся использовать
   // компонент представления в разделяемой компоновке, а не в отдельном представлении.Внутри компоновки
   // компоненты представлений применяются через выражение @await Component.InvokeAsync()

    public class NavigationMenuViewComponent:ViewComponent
    {
        private IProductRepository repositoty;

        public NavigationMenuViewComponent(IProductRepository repo)
        {
            repositoty = repo;
        }

        //public string Invoke()
        //{
        //    return "Hello from the Nav View Component";
        //}

        //Конструктор, принимает аргумент типа IProductRepository.Когда инфраструктуре MVC необходимо
        //создать экземпляр класса компонента представления, она отметит потребность в предоставлении
        //этого аргумента и просмотрит конфигурацию в классе Startup, чтобы выяснить, какой объект реализации
        //должен использоваться.Мы имеем дело с средством внедрения зависимостей как в контроллере, и
        //результат будет аналогичным-обеспечение компоненту представления доступа к данным без необходимости
        //знать используемую реализацию хранилища. Вметоде Invoke () спомощью LINQ выбирается и упорядочивается
        //набор категорий в хранилище, после чего он передается в качестве аргумента методу View (),
        //который визуализирует стандартное частичное представление Razoг. Детали частичного представления
        //возвращаются из метода с применением объекта реализации IViewComponentResult
        public IViewComponentResult Invoke()
        {
            //Свойство RouteData используется для доступа к  данны м запроса, чтобы получить
            //значение выбранной в текущий момент категории. Значение категории можно было
            //бы передать представлению путем  создани яеще одного  класса модели представления
            //но применим объект ViewBag

            //Внутри метода Invoke () мы  динамически создаем войство SelectedCategory
            //в объекте ViewBag и устанавливаем его значение равным значению текущей
            //категории, которое получаем через объект контекста, возвращенный свойством
            //RouteData. ViewBag представляет собой динамический объект, который позволяет
            //определять новые свойства, просто присваивая им значения.

            ViewBag.SelectedCategory = RouteData?.Values["category"];

            return View(repositoty.Products
                .Select(x => x.Category)
                .Distinct()
                .OrderBy(x => x));
        }
    }
}
